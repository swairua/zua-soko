const express = require("express");
const cors = require("cors");
const helmet = require("helmet");
const compression = require("compression");
const morgan = require("morgan");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");

const mpesaService = require("./mpesa");
const { query, transaction, initializeDatabase } = require("./database/db");
require("dotenv").config();

const app = express();
const PORT = process.env.PORT || 5001;

// Middleware
app.use(helmet());
app.use(compression());
app.use(morgan("combined"));
app.use(
  cors({
    origin: process.env.FRONTEND_URL || "http://localhost:3000",
    credentials: true,
  }),
);
app.use(express.json({ limit: "10mb" }));
app.use(express.urlencoded({ extended: true }));

// Constants
const CONSIGNMENT_STATUS = {
  PENDING: "PENDING",
  APPROVED: "APPROVED",
  REJECTED: "REJECTED",
  PRICE_SUGGESTED: "PRICE_SUGGESTED",
  DRIVER_ASSIGNED: "DRIVER_ASSIGNED",
  IN_TRANSIT: "IN_TRANSIT",
  DELIVERED: "DELIVERED",
  COMPLETED: "COMPLETED",
};

// Auth middleware
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers["authorization"];
  const token = authHeader && authHeader.split(" ")[1];

  if (!token) {
    return res.status(401).json({ error: "Access token required" });
  }

  jwt.verify(token, process.env.JWT_SECRET || "demo-secret", (err, user) => {
    if (err) {
      return res.status(401).json({ error: "Invalid token" });
    }
    req.user = user;
    next();
  });
};

const requireRole = (roles) => {
  return (req, res, next) => {
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({ error: "Insufficient permissions" });
    }
    next();
  };
};

// Initialize database
initializeDatabase().catch(console.error);

// ==================== AUTH ROUTES ====================

app.post("/api/auth/login", async (req, res) => {
  try {
    const { phone, password } = req.body;

    if (!phone || !password) {
      return res.status(400).json({ error: "Phone and password are required" });
    }

    const trimmedPhone = phone.trim();
    const result = await query("SELECT * FROM users WHERE phone = $1", [trimmedPhone]);
    const user = result.rows[0];
    
    if (!user) {
      return res.status(401).json({ error: "Invalid credentials" });
    }

    const validPassword = await bcrypt.compare(password, user.password_hash);
    if (!validPassword) {
      return res.status(401).json({ error: "Invalid credentials" });
    }

    await query("UPDATE users SET last_login_at = CURRENT_TIMESTAMP WHERE id = $1", [user.id]);

    const token = jwt.sign(
      { userId: user.id, phone: user.phone, role: user.role },
      process.env.JWT_SECRET || "demo-secret",
      { expiresIn: "7d" }
    );

    const userResponse = {
      id: user.id,
      firstName: user.first_name,
      lastName: user.last_name,
      email: user.email,
      phone: user.phone,
      role: user.role,
      county: user.county,
      verified: user.verified,
      registrationFeePaid: user.registration_fee_paid,
      totalEarnings: parseFloat(user.total_earnings) || 0,
    };

    res.json({
      message: "Login successful",
      user: userResponse,
      token,
    });
  } catch (error) {
    console.error("Login error:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});

app.post("/api/auth/register", async (req, res) => {
  try {
    const { firstName, lastName, email, phone, password, county, role = "CUSTOMER" } = req.body;

    if (!firstName || !lastName || !email || !phone || !password) {
      return res.status(400).json({ error: "All fields are required" });
    }

    const existingUser = await query("SELECT id FROM users WHERE email = $1 OR phone = $2", [email, phone]);
    if (existingUser.rows.length > 0) {
      return res.status(409).json({ error: "User already exists" });
    }

        const hashedPassword = await bcrypt.hash(password, 10);

    const result = await query(`
      INSERT INTO users (first_name, last_name, email, phone, password_hash, role, county, verified, registration_fee_paid)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
      RETURNING id
    `, [firstName, lastName, email, phone, hashedPassword, role, county, true, role !== 'FARMER']);

    const userId = result.rows[0].id;

    if (role === 'FARMER') {
      await query("INSERT INTO wallets (user_id, balance) VALUES ($1, $2)", [userId, 0.00]);
    }

    const token = jwt.sign({ userId, phone, role }, process.env.JWT_SECRET || "demo-secret", { expiresIn: "7d" });

    res.status(201).json({
      message: "User registered successfully",
      user: { id: userId, firstName, lastName, email, phone, role, county, verified: true, registrationFeePaid: role !== 'FARMER' },
      token,
    });
  } catch (error) {
    console.error("Registration error:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});

// ==================== CONSIGNMENT ROUTES ====================

app.get("/api/consignments", authenticateToken, async (req, res) => {
  try {
    const { status, farmer_id } = req.query;
    let queryText = `
      SELECT c.*, u.first_name || ' ' || u.last_name as farmer_name, u.county as farmer_county, u.phone as farmer_phone
      FROM consignments c
      JOIN users u ON c.farmer_id = u.id
      WHERE 1=1
    `;
    const queryParams = [];

    if (status) {
      queryParams.push(status);
      queryText += ` AND c.status = $${queryParams.length}`;
    }
    if (farmer_id) {
      queryParams.push(farmer_id);
      queryText += ` AND c.farmer_id = $${queryParams.length}`;
    }

    queryText += " ORDER BY c.created_at DESC";
    const result = await query(queryText, queryParams);
    
    const consignments = result.rows.map(row => ({
      id: row.id,
      farmerId: row.farmer_id,
      title: row.title,
      description: row.description,
      category: row.category,
      quantity: row.quantity,
      unit: row.unit,
      bidPricePerUnit: parseFloat(row.bid_price_per_unit),
      finalPricePerUnit: row.final_price_per_unit ? parseFloat(row.final_price_per_unit) : null,
      images: row.images || [],
      location: row.location,
      harvestDate: row.harvest_date,
      expiryDate: row.expiry_date,
      status: row.status,
      adminNotes: row.admin_notes,
      driverId: row.driver_id,
      warehouseId: row.warehouse_id,
      createdAt: row.created_at,
      farmer: { name: row.farmer_name, county: row.farmer_county, phone: row.farmer_phone }
    }));

    res.json(consignments);
  } catch (error) {
    console.error("Get consignments error:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});

app.post("/api/consignments", authenticateToken, requireRole(["FARMER"]), async (req, res) => {
  try {
        const { title, description, category, quantity, unit, bidPricePerUnit, images, location, harvestDate, expiryDate } = req.body;

    const result = await query(`
      INSERT INTO consignments (farmer_id, title, description, category, quantity, unit, bid_price_per_unit, images, location, harvest_date, expiry_date, status)
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
      RETURNING id
    `, [req.user.userId, title, description, category, quantity, unit, bidPricePerUnit, images, location, harvestDate, expiryDate, 'PENDING']);

    const consignmentId = result.rows[0].id;
    res.status(201).json({ message: "Consignment created successfully", id: consignmentId });
  } catch (error) {
    console.error("Create consignment error:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});

app.patch("/api/consignments/:id", authenticateToken, requireRole(["ADMIN"]), async (req, res) => {
  try {
    const { id } = req.params;
    const { status, finalPricePerUnit, adminNotes, driverId } = req.body;

    let updateFields = [];
    let queryParams = [];
    let paramCount = 0;

    if (status) {
      paramCount++;
      updateFields.push(`status = $${paramCount}`);
      queryParams.push(status);
    }
    if (finalPricePerUnit) {
      paramCount++;
      updateFields.push(`final_price_per_unit = $${paramCount}`);
      queryParams.push(finalPricePerUnit);
    }
    if (adminNotes) {
      paramCount++;
      updateFields.push(`admin_notes = $${paramCount}`);
      queryParams.push(adminNotes);
    }
    if (driverId) {
      paramCount++;
      updateFields.push(`driver_id = $${paramCount}`);
      queryParams.push(driverId);
    }

    paramCount++;
    updateFields.push(`updated_at = CURRENT_TIMESTAMP`);
    queryParams.push(id);

    await query(`UPDATE consignments SET ${updateFields.join(', ')} WHERE id = $${paramCount}`, queryParams);

    if (status) {
      const consignmentResult = await query("SELECT farmer_id, title FROM consignments WHERE id = $1", [id]);
      const consignment = consignmentResult.rows[0];
      if (consignment) {
        await query(`
          INSERT INTO notifications (user_id, title, message, type)
          VALUES ($1, $2, $3, $4)
        `, [consignment.farmer_id, 'Consignment Update', `Your consignment "${consignment.title}" status has been updated to ${status}`, 'CONSIGNMENT_UPDATE']);
      }
    }

    res.json({ message: "Consignment updated successfully" });
  } catch (error) {
    console.error("Update consignment error:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});

// ==================== PRODUCTS ROUTES ====================

app.get("/api/products", async (req, res) => {
  try {
    const { category, search } = req.query;
    let queryText = `
      SELECT p.*, c.location, c.farmer_id, u.first_name || ' ' || u.last_name as farmer_name
      FROM products p
      JOIN consignments c ON p.consignment_id = c.id
      JOIN users u ON c.farmer_id = u.id
      WHERE p.is_active = true AND p.stock_quantity > 0
    `;
    const queryParams = [];

    if (category) {
      queryParams.push(category);
      queryText += ` AND p.category = $${queryParams.length}`;
    }
    if (search) {
      queryParams.push(`%${search}%`);
      queryText += ` AND (p.name ILIKE $${queryParams.length} OR p.description ILIKE $${queryParams.length})`;
    }

    queryText += " ORDER BY p.created_at DESC";
    const result = await query(queryText, queryParams);
    
    const products = result.rows.map(row => ({
      id: row.id,
      consignmentId: row.consignment_id,
      name: row.name,
      description: row.description,
      category: row.category,
      quantity: row.quantity,
      unit: row.unit,
      pricePerUnit: parseFloat(row.price_per_unit),
      images: row.images || [],
      stockQuantity: row.stock_quantity,
      location: row.location,
      farmer: { id: row.farmer_id, name: row.farmer_name }
    }));

    res.json(products);
  } catch (error) {
    console.error("Get products error:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});

app.get("/api/products/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const result = await query(`
      SELECT p.*, c.location, c.farmer_id, c.harvest_date, c.expiry_date,
             u.first_name || ' ' || u.last_name as farmer_name, u.county as farmer_county
      FROM products p
      JOIN consignments c ON p.consignment_id = c.id
      JOIN users u ON c.farmer_id = u.id
      WHERE p.id = $1 AND p.is_active = true
    `, [id]);

    if (result.rows.length === 0) {
      return res.status(404).json({ error: "Product not found" });
    }

    const row = result.rows[0];
    const product = {
      id: row.id,
      consignmentId: row.consignment_id,
      name: row.name,
      description: row.description,
      category: row.category,
      quantity: row.quantity,
      unit: row.unit,
      pricePerUnit: parseFloat(row.price_per_unit),
      images: row.images || [],
      stockQuantity: row.stock_quantity,
      location: row.location,
      harvestDate: row.harvest_date,
      expiryDate: row.expiry_date,
      farmer: { id: row.farmer_id, name: row.farmer_name, county: row.farmer_county }
    };

    res.json(product);
  } catch (error) {
    console.error("Get product error:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});

// ==================== ORDERS ROUTES ====================

app.post("/api/orders", async (req, res) => {
  try {
    const { items, customerInfo, paymentMethod, mpesaPhone, deliveryFee, totalAmount } = req.body;
    const orderId = uuidv4();
    const customerId = req.user?.userId || null;

    await transaction(async (client) => {
      await client.query(`
        INSERT INTO orders (id, customer_id, customer_info, total_amount, delivery_fee, payment_method, delivery_address, status)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
      `, [orderId, customerId, JSON.stringify(customerInfo), totalAmount, deliveryFee, paymentMethod, customerInfo.address, 'PENDING']);

      for (const item of items) {
        const orderItemId = uuidv4();
        const totalPrice = item.price * item.quantity;
        await client.query(`
          INSERT INTO order_items (id, order_id, product_id, quantity, price_per_unit, total_price)
          VALUES ($1, $2, $3, $4, $5, $6)
        `, [orderItemId, orderId, item.productId, item.quantity, item.price, totalPrice]);

        await client.query(`
          UPDATE products SET stock_quantity = stock_quantity - $1, updated_at = CURRENT_TIMESTAMP
          WHERE id = $2 AND stock_quantity >= $1
        `, [item.quantity, item.productId]);
      }

            if (paymentMethod === 'MPESA') {
        await client.query(`
          INSERT INTO payments (user_id, order_id, amount, payment_method, mpesa_phone, status)
          VALUES ($1, $2, $3, $4, $5, $6)
        `, [customerId, orderId, totalAmount, paymentMethod, mpesaPhone, 'PENDING']);
      }
    });

    res.status(201).json({ message: "Order created successfully", orderId: orderId });
  } catch (error) {
    console.error("Create order error:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});

// ==================== PAYMENT ROUTES ====================

app.post("/api/payments/registration-fee", authenticateToken, requireRole(["FARMER"]), async (req, res) => {
  try {
    const { phoneNumber } = req.body;
    const userResult = await query("SELECT registration_fee_paid FROM users WHERE id = $1", [req.user.userId]);
    const user = userResult.rows[0];

    if (user.registration_fee_paid) {
      return res.status(400).json({ error: "Registration fee already paid" });
    }

    const stkResponse = await mpesaService.stkPush({
      phoneNumber: phoneNumber,
      amount: 300,
      accountReference: `REG-${req.user.userId}`,
      transactionDesc: "Farmer Registration Fee",
    });

        if (stkResponse.ResponseCode === "0") {
      await query(`
        INSERT INTO payments (user_id, amount, payment_method, mpesa_phone, mpesa_checkout_request_id, reference_code, description, status)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
      `, [req.user.userId, 300, 'MPESA', phoneNumber, stkResponse.CheckoutRequestID, `REG-${req.user.userId}`, 'Farmer Registration Fee', 'PENDING']);

      res.json({
        message: "Registration fee payment initiated successfully",
        checkoutRequestID: stkResponse.CheckoutRequestID,
        customerMessage: stkResponse.CustomerMessage,
      });
    } else {
      res.status(400).json({ error: "Failed to initiate payment" });
    }
  } catch (error) {
    console.error("Registration fee payment error:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});

app.post("/api/payments/callback", async (req, res) => {
  try {
    const { Body } = req.body;
    const stkCallback = Body?.stkCallback;
    if (!stkCallback) return res.status(400).json({ error: "Invalid callback format" });

    const { CheckoutRequestID, ResultCode } = stkCallback;
    const paymentResult = await query("SELECT * FROM payments WHERE mpesa_checkout_request_id = $1", [CheckoutRequestID]);
    if (paymentResult.rows.length === 0) return res.status(404).json({ error: "Payment record not found" });

    const payment = paymentResult.rows[0];
    const success = ResultCode === 0;

    await query("UPDATE payments SET status = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2", [success ? 'COMPLETED' : 'FAILED', payment.id]);

    if (success) {
      if (payment.description === 'Farmer Registration Fee') {
        await query("UPDATE users SET registration_fee_paid = true, updated_at = CURRENT_TIMESTAMP WHERE id = $1", [payment.user_id]);
        await query(`
          INSERT INTO notifications (user_id, title, message, type)
          VALUES ($1, $2, $3, $4)
        `, [payment.user_id, 'Registration Fee Paid', 'Your registration fee has been paid successfully. Your account is now active.', 'PAYMENT_SUCCESS']);
      }
      if (payment.order_id) {
        await query("UPDATE orders SET payment_status = 'COMPLETED', status = 'CONFIRMED', updated_at = CURRENT_TIMESTAMP WHERE id = $1", [payment.order_id]);
      }
    }

    res.json({ message: "Callback processed successfully" });
  } catch (error) {
    console.error("Callback processing error:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});

// ==================== WALLET ROUTES ====================

app.get("/api/wallet", authenticateToken, requireRole(["FARMER"]), async (req, res) => {
  try {
    const result = await query(`
      SELECT w.*, 
             array_agg(
               json_build_object('id', wt.id, 'type', wt.type, 'amount', wt.amount, 'description', wt.description, 'createdAt', wt.created_at)
               ORDER BY wt.created_at DESC
             ) FILTER (WHERE wt.id IS NOT NULL) as transactions
      FROM wallets w
      LEFT JOIN wallet_transactions wt ON w.id = wt.wallet_id
      WHERE w.user_id = $1
      GROUP BY w.id
    `, [req.user.userId]);

    if (result.rows.length === 0) return res.status(404).json({ error: "Wallet not found" });

    const row = result.rows[0];
    const wallet = {
      id: row.id,
      balance: parseFloat(row.balance),
      pendingBalance: parseFloat(row.pending_balance),
      totalEarned: parseFloat(row.total_earned),
      totalWithdrawn: parseFloat(row.total_withdrawn),
      transactions: row.transactions || [],
    };

    res.json(wallet);
  } catch (error) {
    console.error("Get wallet error:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});

app.post("/api/wallet/withdraw", authenticateToken, requireRole(["FARMER"]), async (req, res) => {
  try {
    const { amount, phoneNumber } = req.body;
    if (amount < 10) return res.status(400).json({ error: "Minimum withdrawal amount is KES 10" });

    const walletResult = await query("SELECT * FROM wallets WHERE user_id = $1", [req.user.userId]);
    const wallet = walletResult.rows[0];
    if (!wallet || parseFloat(wallet.balance) < amount) return res.status(400).json({ error: "Insufficient balance" });

    const stkResponse = await mpesaService.stkPush({
      phoneNumber: phoneNumber,
      amount: amount,
      accountReference: `WTH-${req.user.userId}`,
      transactionDesc: "Wallet Withdrawal",
    });

        if (stkResponse.ResponseCode === "0") {
      const newBalance = parseFloat(wallet.balance) - amount;

      await transaction(async (client) => {
        await client.query("UPDATE wallets SET balance = $1, total_withdrawn = total_withdrawn + $2, updated_at = CURRENT_TIMESTAMP WHERE id = $3", [newBalance, amount, wallet.id]);
        await client.query(`
          INSERT INTO wallet_transactions (wallet_id, user_id, type, amount, balance_before, balance_after, description, reference)
          VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        `, [wallet.id, req.user.userId, 'WITHDRAWAL', amount, parseFloat(wallet.balance), newBalance, 'Wallet Withdrawal', `WTH-${req.user.userId}`]);
        await client.query(`
          INSERT INTO payments (user_id, amount, payment_method, mpesa_phone, mpesa_checkout_request_id, reference_code, description, status)
          VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        `, [req.user.userId, amount, 'MPESA', phoneNumber, stkResponse.CheckoutRequestID, `WTH-${req.user.userId}`, 'Wallet Withdrawal', 'PENDING']);
      });

      res.json({
        message: "Withdrawal initiated successfully",
        transactionId: transactionId,
        checkoutRequestID: stkResponse.CheckoutRequestID,
        customerMessage: stkResponse.CustomerMessage,
        newBalance: newBalance,
      });
    } else {
      res.status(400).json({ error: "Failed to initiate withdrawal" });
    }
  } catch (error) {
    console.error("Wallet withdrawal error:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});

// ==================== DRIVER ROUTES ====================

app.get("/api/driver/assignments", authenticateToken, requireRole(["DRIVER"]), async (req, res) => {
  try {
    const result = await query(`
      SELECT c.*, u.first_name || ' ' || u.last_name as farmer_name, u.phone as farmer_phone, u.county as farmer_county
      FROM consignments c
      JOIN users u ON c.farmer_id = u.id
      WHERE c.driver_id = $1 AND c.status IN ('DRIVER_ASSIGNED', 'IN_TRANSIT')
      ORDER BY c.created_at DESC
    `, [req.user.userId]);

    const assignments = result.rows.map(row => ({
      id: row.id,
      title: row.title,
      description: row.description,
      quantity: row.quantity,
      unit: row.unit,
      location: row.location,
      status: row.status,
      farmer: {
        user: { firstName: row.farmer_name.split(' ')[0], lastName: row.farmer_name.split(' ')[1] || '' },
        phone: row.farmer_phone,
        county: row.farmer_county,
      },
      createdAt: row.created_at,
    }));

    res.json(assignments);
  } catch (error) {
    console.error("Get driver assignments error:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});

app.put("/api/driver/assignments/:id/status", authenticateToken, requireRole(["DRIVER"]), async (req, res) => {
  try {
    const { id } = req.params;
    const { status, notes } = req.body;

    const assignmentResult = await query("SELECT * FROM consignments WHERE id = $1 AND driver_id = $2", [id, req.user.userId]);
    if (assignmentResult.rows.length === 0) return res.status(404).json({ error: "Assignment not found" });

    await query("UPDATE consignments SET status = $1, admin_notes = $2, updated_at = CURRENT_TIMESTAMP WHERE id = $3", [status, notes || '', id]);

    const consignment = assignmentResult.rows[0];
    await query(`
      INSERT INTO notifications (user_id, title, message, type)
      VALUES ($1, $2, $3, $4)
    `, [consignment.farmer_id, 'Delivery Update', `Your consignment "${consignment.title}" status has been updated to ${status}`, 'DELIVERY_UPDATE']);

    res.json({ message: "Assignment status updated successfully" });
  } catch (error) {
    console.error("Update assignment status error:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});

app.put("/api/driver/location", authenticateToken, requireRole(["DRIVER"]), async (req, res) => {
  try {
    const { latitude, longitude, timestamp } = req.body;
    console.log(`ğŸ“ Driver ${req.user.userId} location updated:`, { latitude, longitude, timestamp });
    res.json({ message: "Location updated successfully" });
  } catch (error) {
    console.error("Update driver location error:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});

// ==================== ADMIN ROUTES ====================

app.get("/api/admin/users", authenticateToken, requireRole(["ADMIN"]), async (req, res) => {
  try {
    const result = await query(`
      SELECT id, first_name, last_name, email, phone, role, county, verified, registration_fee_paid, created_at
      FROM users ORDER BY created_at DESC
    `);

    const users = result.rows.map(row => ({
      id: row.id,
      firstName: row.first_name,
      lastName: row.last_name,
      email: row.email,
      phone: row.phone,
      role: row.role,
      county: row.county,
      verified: row.verified,
      registrationFeePaid: row.registration_fee_paid,
      createdAt: row.created_at,
    }));

    res.json(users);
  } catch (error) {
    console.error("Get admin users error:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});

app.get("/api/admin/analytics", authenticateToken, requireRole(["ADMIN"]), async (req, res) => {
  try {
    const [userStats, orderStats, paymentStats] = await Promise.all([
      query("SELECT role, COUNT(*) as count FROM users GROUP BY role"),
      query("SELECT status, COUNT(*) as count FROM orders GROUP BY status"),
      query("SELECT SUM(amount) as total FROM payments WHERE status = 'COMPLETED'"),
    ]);

    const analytics = {
      usersByRole: userStats.rows.reduce((acc, row) => { acc[row.role] = parseInt(row.count); return acc; }, {}),
      ordersByStatus: orderStats.rows.reduce((acc, row) => { acc[row.status] = parseInt(row.count); return acc; }, {}),
      totalRevenue: parseFloat(paymentStats.rows[0]?.total || 0),
    };

    res.json(analytics);
  } catch (error) {
    console.error("Get analytics error:", error);
    res.status(500).json({ error: "Internal server error" });
  }
});

// Start server
app.listen(PORT, () => {
  console.log(`ğŸš€ Server running on http://localhost:${PORT}`);
  console.log(`ğŸ“Š Environment: ${process.env.NODE_ENV || 'development'}`);
  console.log(`ğŸ¯ Frontend URL: ${process.env.FRONTEND_URL || 'http://localhost:3000'}`);
  console.log(`ğŸ—„ï¸  Database: PostgreSQL`);
  console.log(`ğŸ’³ M-Pesa: ${process.env.MPESA_BASE_URL?.includes('api.safaricom.co.ke') ? 'Production' : 'Sandbox'} mode`);
});

module.exports = app;
